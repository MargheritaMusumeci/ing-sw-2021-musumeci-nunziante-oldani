Musumeci:

da fare:
-mostrare il regolamento
-controllare i test
-controllare che ci siano tutti i javadoc
-sistemarel'uml iniziale
-fare gli uml richiesti (completo più classi pricipali)
-fare il README
-eliminare gli sout
-try run.later
-pulire il codice dai warnings


NOTE PER MARGHE PER SISTEMARE IL SEQUENCE DIAGRAM
    - Il secondo message mandato dal client andrebbe spiegato meglio (chi è?)
    - Quando arriva un messaggio dal server bisognerebbe dire cosa fa il message hadler ovvero chiamare noyifyAll()
        changeScene()
        Un esempio è quando arrica il messaggio "SendResourcesBoughtFromMarket"

in atto:

fatto:
-fine gioco --> sistemare looser --> dovrebbe andare
-POPE CARD --> se supero la posizione non gira la carta
-basic production da controllare
-sistemato problema con discard leader card (arrivata il nack e ricaricava la pagina sbagliata)
-controllare attivazione/disattivazione leader
-far vedere il mercato e l'evolution section prima
-visualizzare dashbord degli avversari --> costuire la view corretta
-abbellire il fine gioco
-far scegliere la produzione delle leader card --> sostituisco la checkbox con un bottone di attivazione della prosuzione che mi rimanda alla scena dove scelgo cosa produrre
-label di errore
- stock non si aggiornava
- leader card stock non facevano vedere le risorse
-controllare le biglie bianche
- flag ack vs update
- controllare multigame (otherplayer turn) --> carte leader stockbox plus - > in teoria lo avevo già provato (non mi va)
- controllare production leader controller --> non si vedono le biglie prodotte e non sempra che tu abbia effettuato la mossa
- controllare other player view
- controllare le risorse inserite quando ci sono due leader card no more white attive
- see other view
- cambiare l'icona dell'applicazione

Nunziante:

Oldani:

- add comments to methods
- modificare la signature di updateMarket nell'uml
- sistemare uml --> product è products nelle productionCards
- test alcune carte del evolutionSection
- test del buy senza la get che va tolto

Generali:

- pensare al controller --> UML
- decidere come sistemare la sitazione lorezoPlayer
- sequence diagram
- aggiungere UML su github
- dobbiamo decidere come aggiungere la nuova produzion
- invalidPlaceException c'è un motivo se non eredita da Exception ma da Throwable?
- attenzione: gli altri player non devono vedere le leader card fino a quando non vengono attivate
- come viene gestita la produzione plus?

DOMANDE TUTORATO:

0-7 AZIONI

8-15 PRINT e facciamo due switch più piccoli

faith track mancano delle informazioni --> posizioni del pope section
print fa un file di testo --> reader

CONTROLLARE MAVEN --> DOVREBBE BASTARE AVER INSERITO LA DEPENDENCY JAVAFX

sistemi più puliti per lo switch --> state pattern
action o command pattern

cambiare anche gli instanceof dei messaggi

cambiare switch solo game -->

--- devo dare la possibilità all'utente di fare il riordino dello stock se in realà è una cosa autogestita?
no non necessaria se ho gia fatto un manage automatico

--- resilienza alle disconnessioni per partita single player

tento una riconnessione e in caso termino



- Devo gestire il caso in cui la disconnessione avvenga tra l'avvio del gioco e la registrazione dei giocatori nell'hashmap con l'id del game?

    E' un caso limite, non veniamo penalizzati se la gestiamo "approsimatiamente".
    Dobbiamo gestire in modo corretto la disconnesione e riconnesione del player a gioco iniziato.

    Per quanto riguarda la domanda
    Posso escludere dal gioco il client che si è disconnesso prima dell'effettivo inizio o rimandare tutti nella lobby e attendere un ulteriore player.

- È giusto implementare il server come qualcso che non attende mai il client e che non manda mai messaggi che comportiano l'esecuzione diretta di metodi da parte
  del client? In questo modo il server risponde solo a domande ed esegue le operazioni solo se il giocatore che le richiede è quello giusto ( e le operazioni sono giuste)
  Esempio --> Compro le risorse e non mi viene chiesto dal server quali voglio tenere e quali no. Sono io che lo avviso ed è la view che superviziona questo processo. Il server
  saprà solo se può o meno inserire quelle richieste dal client. 

    La possivilità che il server invii messaggi o meno al client dipende dalle nostre scelte imlementative. Fare in modo che solo il client possa mandare messaggi va più che bene.
    Per quanto riguarda il multi-socket è un flop. Il rischio di avere più socket sta nel:
    1)rischio di collisioni e concorrenza sgradevole
    2)problema del ping-> ogni ping garantisce solo che la socket che lo ha inviato è ancora attiva

    Possibili alternative alla nostra idea:
    1)Unico socket che riceve i messaggi. In base al tipo di messaggio ricevuto smista il contenuto a diversi socket che si occuperano della  gesione
    2)Implementare un observable che legge sulla socket e notifica ai thread

    RICORDIAMOCI DI RIDURRE IL TEMPO DI PING --> CONSIGLIATO A 2

    Dobbiamo:
    -->ORGANIZZARE IL MODEL IN SOTTOPACKAGE

    -->TEST STATICO PER QUANTO RIGUARDA LE CARTE --> MEGLIO NON FAREMETODI SOLO PER I TEST

    VEDO SE SUCCEDE CIò CHE MI ASPETTO



    Multi-game --> abbandonare il singleton è complesso e perde di significato.

    no classi astratte --> tutte le carte classe astratta comune
    nella classe concreta aggiungiamo oggetti
    -->strategy ?

RISPOSTE TUTORATO:

- I controlli sulla validità dei parametri dove li devo fare? Noi li faremmo nel controller
        Vanno fatti nel model

- Nelle EvolutionCard le tipologie di risorse per requirements, products e cost sono mappate intrinsecamente dentro l'array
    che le contiene come //rock, shield, coin, servant, faith. Può esseere un problema?
        user un hashmap {resource, valore}

- se va bene il metodo di creazione delle carte da parte di file
        usare la libreiria gson

- E' errato restituire un valore per riferimento e non per copia anche se l'attributo è privato e
  non esistono metodi setter della classe in questione?

  No, non è un problema
  solo attenzioni alle modifiche concorrenti

- Dove parte il gioco? Chi sarà in grado di gestire l'inizio una volta che i player sono collegati al server? Il controller?

   --> controller costruisce tutto il gioco
    il client sa solo di se stesso
    network parla generalmente con il controller

- Devo testare anche i metodi get e in quel caso cosa dovrei fare? Quale è la verifica che viene imposta?

- Devo testare che tutte le carte caricate nela evolutionSection dal json siano caricate giuste o basta verificare
  che una di quelle caricate sia corretta?

    no test dei metodi get
    solo alcune prove delle carte json

- Dobbiamo gestire gli eventuali errori (parametri non validi arrivati al model/controller)
  con exception o ci sono altri modi consiglaiti? Chi gestirà poi tutte le exception?

  Se siamo nel Model possiamo supporre che venga fatto un precontrollo a livello della View e del Controller.
  Quidni mi aspetto di ricevere già dei dati corretti.
  Se lancio un eccezione chi la riceve la deve gestire senza interrompere o "distruggere" la partita.
  Se riesce il controller puo gestirla in automatico se no devo rispedire alla view il problema


- Posso scegliere dove mettere le risorse appena comprate a magazzino vuoto o vanno messe in automatico?
    ( su slack ci sono rispsote constrastanti)

    A nostra discrezione


- Creare nel controller la classe SoloGameHandler che in caso di sologame gestisca le mosse di un ipotetico
  lorenzo usando le action card
  e usando gli oggetti di game (market e le evolutionCardSection)
  Metterà l'active player a null durante la computazione
  Aggiorna posizoone pope track di lorenzo

    piu pulito mettere un finto player lorenzo
    oppure dire che è il turno di lorenzo


???? creo i giocatori --> creo il gioco --> assegno il gioco ai giocatori
???? abbiamo controllato che l'inkwell lo abbia solo un giocatore
???? dobbiamo testare i messaggi per la copertura del codice

???? a volte non passo il test checkendgame di solo game
???? a volte non passo il test store resources
